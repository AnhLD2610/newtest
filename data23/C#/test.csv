body,code,title
"I am using NDesk.Options to parse command line arguments for a C # command line program . It is working fine , except I want my program to exit unsuccessfully , and show the help output , if the user includes arguments that I did not expect.I am parsing options thusly : With this code , if I use an argument improperly , such as specifying -- filter without =myfilter after it then NDesk.Options will throw an OptionException and everything will be fine . However , I also expected an OptionException to be thrown if I pass in an argument that does n't match my list , such as -- someOtherArg . But this does not happen . The parser just ignores that and keeps on trucking.Is there a way to detect unexpected args with NDesk.Options ?","var options = new OptionSet { { `` r|reset '' , `` do a reset '' , r = > _reset = r ! = null } , { `` f|filter= '' , `` add a filter '' , f = > _filter = f } , { `` h| ? |help '' , `` show this message and exit '' , v = > _showHelp = v ! = null } , } ; try { options.Parse ( args ) ; } catch ( OptionException ) { _showHelp = true ; return false ; } return true ;",NDesk.Options - detect invalid arguments
"Basically NUnit , xUnit , MbUnit , MsTest and the like have methods similar to the following : However , there are a limited number of such comparison operators built-in ; and they duplicate the languages operators needlessly . When I want anything even slightly complex , such as ... I 'm often either left digging through the manual to find the equivalent of the expression in NUnit-speak , or am forced to fall-back to plain boolean assertions with less helpful error messages.C # , however , integrates well with arbitrary Expressions - so it should be possible to have a method with the following signature : Such a method could be used to both execute the test ( i.e . validate the assertion ) and to also provide less-opaque diagnostics in case of test failure ; after all , an expression can be rendered to pseudo-code to indicate which expression failed ; and with some effort , you could even evaluate failing expressions intelligently to give some clue of the value of subexpressions.For example : At a minimum , it would make the use of a parallel language for expressions unnecessary , and in some cases it might make failure messages more useful.Does such a thing exist ? Edit : After trying ( and liking ! ) Power Assert , I ended up reimplementing it to address several limitations . My variant of this is published as ExpressionToCode ; see my answer below for a list of improvements .","Assert.IsGreater ( a , b ) //or , a little more discoverableAssert.That ( a , Is.GreaterThan ( b ) ) Assert.That ( a.SequenceEquals ( b ) ) void That ( Expression < Func < bool > > expr ) ; Assert.That ( ( ) = > a == b ) ; //could inspect expression and print a and bAssert.That ( ( ) = > a < b & & b < c ) ; //could mention the values of `` a < b '' and `` b < c '' and/or list the values of a , b , and c .",Is there a C # unit test framework that supports arbitrary expressions rather than a limited set of adhoc methods ?
"I have a problem that may be fairly unique . I have an application that runs on a headless box for long hours when I am not present , but is not critical . I would like to be able to debug this application remotely using Visual Studio . In order to do so , I have code that looks like this : The idea being that this way , I hit an error while I am away , and the application effectively pauses itself and waits for a remote debugger attach , which after the first continue automatically gets the right context thanks to the Debugger.Break call.Here is the problem : Implementing SuspendAllButCurrentThread turns out to be nontrivial . Thread.Suspend is deprecated , and I ca n't P/Invoke down to SuspendThread because there 's no one-to-one mapping between managed threads and native threads ( since I need to keep the current thread alive ) . I do n't want to install Visual Studio on the machine in question if it can possibly be avoided . How can I make this work ?","// Suspend all other threads to prevent loss// of state while we investigate the issue.SuspendAllButCurrentThread ( ) ; var remoteDebuggerProcess = new Process { StartInfo = { UseShellExecute = true , FileName = MsVsMonPath ; } } ; // Exception handling and early return removed here for brevity.remoteDebuggerProcess.Start ( ) ; // Wait for a debugger attach.while ( ! Debugger.IsAttached ) { Thread.Sleep ( 500 ) ; } Debugger.Break ( ) ; // Once we get here , we 've hit continue in the debugger . Restore all of our threads , // then get rid of the remote debugging tools.ResumeAllButCurrentThread ( ) ; remoteDebuggerProcess.CloseMainWindow ( ) ; remoteDebuggerProcess.WaitForExit ( ) ;",C # suspending all threads
"The following code works as I want it to , but causes a warning : Warning 1 Because this call is not awaited , execution of the current method continues before the call is completed . Consider applying the 'await ' operator to the result of the call.Is there an alternative to Task.Run ( ) that will kick off this thread in a nice terse way ?","/// < summary > /// StartSubscriptionsAsync must be called if you want subscription change notifications./// This starts the subscription engine . We always create one subscription for/// Home DisplayName to start ( but ignore any updates ) ./// < /summary > public async Task StartSubscriptionsAsync ( ) { await _subscriptionClient.ConnectAsync ( Host , Port ) ; // Generates a compiler warning , but it is what we want Task.Run ( ( ) = > ReadSubscriptionResponses ( ) ) ; // We do a GetValue so we know we have a good connection SendRequest ( `` sys : //Home ? f ? ? '' + `` Name '' ) ; if ( FastMode ) EnableFastMode ( ) ; foreach ( var subscription in _subscriptions ) { SendSubscriptionRequest ( subscription.Value ) ; } }",Alternative to Task.Run that does n't throw warning
"I 'm writing a Roslyn analyzer to raise a diagnostic when a certain library method is used within a certain method in a certain kind of class , but I can not retrieve the symbol in the parent or ancestor syntax nodes.For example , And this is the code for analyzing the SyntaxNode of SyntaxKind.InvocationExpressionSo my question is , is it possible to retrieve SymbolInfo from an ancestor SyntaxNode.Is my approach correct or should I try another approach ?",class C { void M ( ) { MyLibrary.SomeMethod ( ) ; } } private void AnalyzeNode ( SyntaxNodeAnalysisContext context ) { var invocationExpression = context.Node as InvocationExpressionSyntax ; var methodSymbol = context.SemanticModel.GetSymbolInfo ( invocationExpression ) .Symbol as IMethodSymbol ; if ( methodSymbol == null ) { return ; } // check if it is the library method I am interested in . No problems here if ( ! methodSymbol.Name.Equals ( `` SomeMethod '' ) || ! methodSymbol.ContainingSymbol.ToString ( ) .Equals ( `` MyNamespace.MyLibrary '' ) ) { return ; } // this retrieves outer method `` M '' . var outerMethodSyntax = invocationExpression.FirstAncestorOrSelf < MethodDeclarationSyntax > ( ) ; if ( outerMethodSyntax == null ) { return ; } // symbol.Symbol is always null here var symbol = context.SemanticModel.GetSymbolInfo ( outerMethodSyntax ) ; ...,Roslyn : Retrieving Symbol in parent or ancestor SyntaxNode
"I 'm working on some test automation for a service , and figured out a neat way to roll up some common setup & verification into a 'session ' class.Conceptually , a test case might look like this : In the Session object constructor I set up a connection to the service I 'm testing with proper authentication per role etc , and in the session Dispose ( ) method I have a common validation block that , for instance , checks that no server-side errors or warnings have been raised during the session lifetime.Now , of course , this is sort of abusing the IDispose pattern , and if test code inside a using blocks throws an exception AND the validation block also throws an exception the second exception will mask the first.Conceptually , if we have this scenario : ... and the assert fails or the call to managerSession.DoJob ( ) throws an exception , then I would like the Session Dispose ( ) method to skip the validation block , i.e ... .such that the test method never fails with 'Service connection has errors ' if it actually fails with 'Manager did not do his job'My question is : Is it at all possible to implement the 'NoExceptionThrown ( ) ' method here ? Is there some global property that can be checked , or something hidden in Thread.CurrentThread that could be utilized ? Update : My question is not how to refactor this : - ) I could of course use this pattern instead : With the static method ForRole ( ) defined likeBut I am curious whether there exists some way of grabbing the exception state as described above .","using ( var managerSession = new Session ( managerRole ) ) { // A manager puts some items in warehouse } using ( var employeeSession = new Session ( employeeRole ) ) { // An employee moves items from warehouse to store } using ( var customerSession = new Session ( customerRole ) ) { // A customer can buy items from the store } using ( var managerSession = new Session ( managerRole ) ) { Assert.IsTrue ( managerSession.DoJob ( ) , `` Manager did not do his job '' ) ; } public void Dispose ( ) { if ( NoExceptionThrown ( ) ) { Assert.IsFalse ( this.serviceConnection.HasErrors ( ) , `` Service connection has errors '' ) ; } this.serviceConnection.Dispose ( ) ; } Session.ForRole ( managerRole , ( session ) = > { /* Test code here */ } ) ; public static void ForRole ( Role r , Action < Session > code ) { var session = new Session ( r ) ; try { code ( session ) ; Assert.IsFalse ( session.serviceConnection.HasErrors ( ) ) ; } finally { session.Dispose ( ) ; } }",How can I check if any exception has already been thrown ?
"In C # , what 's the best way to delay handling of all known events until an entity has been fully modified ? Say , for example that an entity - MyEntity - has the properties ID , Name and Description ... When modifying each of these properties , an event is fired for each modification.Sometimes , the ID is the only property modified and sometimes all properties are modified . I want the registered listeners of the modification event to wait until all properties being modified in the `` batch '' have been modified.What is the best way to accomplish this ? In my head , something similar to the UnitOfWork-pattern , where it is possible to wrap a using statement around the method call in the top level of the call stack but have no clue how to implement such a thing ... Edit : As a clarification ... Listeners are spread out through the application and are executing in other threads . Another actor sets - for example - the name it must call the MyEntity.Name property to set the value . Due to the design , the modification of the Name property can trigger other properties to change , thus the need for listeners to know that the modification of properties have been completed .",public class MyEntity { public Int32 ID { get ; set ; } public String Name { get ; set ; } public String Description { get ; set ; } },Delay event handling until events have been fired
"I have an object with a string-typed parameter called 'baan_cat_fam_code ' . The code below is my attempt to find all items in the query that have a baan_cat_fam_code that exist in a generic string list called catFamCd . The problem is that this wo n't compile - I get an error that states for some reason the predicate s is typed as char . So I append .ToString ( ) to the argument in the .Contains method . However , when the code runs , I get the following exception thrown when the result of the query is bound to a listbox.This has got me scratching my head . Any assistance would be greatly appreciated.Thanks !",query = query.Where ( r = > r.baan_cat_family_code.Any ( s = > catFamCode.Contains ( s ) ) ) ; `` Argument type 'char ' is not assignable to parameter type 'string ' '' `` The argument 'value ' was the wrong type . Expected 'System.Char ' . Actual 'System.String ' . '',LINQ Any ( ) argument versus parameter data type issues
"This is something I 'm having a hard time wrapping my head around . I understand that Action < T > is contravariant and is probably declared as such.However , I do n't understand why an Action < Action < T > > is covariant . T is still not in an output position . I 'd really appreciate it if someone could try to explain the reasoning / logic behind this . I dug around a little bit and found this blog post which tries to explain it . In particular , I did n't quite follow what was meant here under the `` Explanation for covariance of input '' subsection . It is the same natural if the “ Derived - > Base ” pair is replaced by “ Action - > Action ” pair .",internal delegate void Action < in T > ( T t ) ;,Why is Action < Action < T > > covariant ?
